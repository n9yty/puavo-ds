#!/usr/bin/ruby1.9.1

require "erb"
require "yaml"
require 'tempfile'
require 'puavo/etc'
require 'optparse'

def parse_erb(basename)
  ldif_template = File.read("templates/#{basename}.ldif.erb")
  ldif = ERB.new(ldif_template, 0, "%<>")

  tempfile = Tempfile.open(basename)
  tempfile.puts ldif.result
  tempfile.close
  
  return tempfile
end

def ask_dn(question, puavo_etc_method, default)
  begin
    value = PUAVO_ETC.send(puavo_etc_method)
  rescue Errno::ENOENT
    print "#{question} (#{default}): "
    value = STDIN.gets.chomp
    value = default if value.empty?
    PUAVO_ETC.write(puavo_etc_method.to_sym, value)
  end
  return value
end

def ask_password(question, puavo_etc_method)
  begin
    value = PUAVO_ETC.send(puavo_etc_method)
  rescue Errno::ENOENT
    value = ""
    while value.empty? do
      print "#{question}: "
      value = STDIN.gets.chomp
    end
    PUAVO_ETC.write(puavo_etc_method.to_sym, value)
  end
  return value
end

puts "\nInitialize slapd with Puavo configuration"
puts

@rootdn = ask_dn("root dn", "ldap_dn", "uid=admin,o=puavo")
@rootpw = ask_password("root password", "ldap_password")

@puavodn = ask_dn("puavo dn", "ds_puavo_dn", "uid=puavo,o=puavo")
@puavopw = ask_password("puavo password", "ds_puavo_password")

@puppetdn = ask_dn("puppet dn", "ds_puppet_dn", "uid=puppet,o=puavo")
@puppetpw = ask_password("puppet password", "ds_puppet_password")

@kdcdn = ask_dn("kdc dn", "ds_kdc_dn", "uid=kdc,o=puavo")
@kdcpw = ask_password("kdc password", "ds_kdc_password")

@kadmindn = ask_dn("kadmin dn", "ds_kadmin_dn", "uid=kadmin,o=puavo")
@kadminpw = ask_password("kadmin password", "ds_kadmin_password")

@monitordn = ask_dn("monitor dn", "ds_monitor_dn", "uid=monitor,o=puavo")
@monitorpw = ask_password("monitor password", "ds_monitor_password")

@slavedn = ask_dn("slave dn", "ds_slave_dn", "uid=slave,o=puavo")
@slavepw = ask_password("slave password", "ds_slave_password")

puts "Using #{@rootdn} as rootdn"

@rootpw_hash=`slappasswd -h "{SSHA}" -s "#{@rootpw}"`.gsub(/\n/,"")
@puavopw_hash=`slappasswd -h "{SSHA}" -s "#{@puavopw}"`.gsub(/\n/,"")
@puppetpw_hash=`slappasswd -h "{SSHA}" -s "#{@puppetpw}"`.gsub(/\n/,"")
@kdcpw_hash=`slappasswd -h "{SSHA}" -s "#{@kdcpw}"`.gsub(/\n/,"")
@kadminpw_hash=`slappasswd -h "{SSHA}" -s "#{@kadminpw}"`.gsub(/\n/,"")

# First whole slapd configuration and all data is wiped out

`/etc/init.d/slapd stop`
`killall -9 slapd`
`rm -rf /var/lib/ldap/*`

# AppArmor rules allow slapd to access files under /var/lib/ldap so
# we'll just create new directories under it for different databases:
#
# /var/lib/ldap/o=puavo

`mkdir -p /var/lib/ldap/o=puavo`

`rm -rf /etc/ldap/slapd.d/*`

`cp certs/slapd-ca.crt /etc/ssl/certs/slapd-ca.crt`
`cp certs/slapd-server.crt /etc/ssl/certs/slapd-server.crt`
`cp certs/slapd-server.key /etc/ssl/certs/slapd-server.key`

`chown openldap.openldap /etc/ssl/certs/slapd-server.key`
`chown openldap.openldap /etc/ssl/certs/slapd-server.crt`
`chown openldap.openldap /etc/ssl/certs/slapd-ca.crt`

# As /etc/ldap/slapd.d is now totally empty, slapd won't start before
# initial config is added with slapadd.
#
# Initialize cn=config from a template ldif file

tempfile = parse_erb("init_ldap")
puts `slapadd -l #{tempfile.path} -F /etc/ldap/slapd.d -b "cn=config"`
tempfile.delete

# Initialize o=puavo from a template ldif file

tempfile = parse_erb("init_puavo_db")
puts `slapadd -l #{tempfile.path} -F /etc/ldap/slapd.d -b "o=Puavo"`
tempfile.delete

# slapdadd leaves the files owner by root, so let's fix those

`chown -R openldap.openldap /etc/ldap/slapd.d`
`chown -R openldap.openldap /var/lib/ldap/o=puavo`
`chmod 0750 /var/lib/ldap/o=puavo`

`/etc/init.d/slapd start`
`sleep 5`

# slapd should be running now and the rest of the modifications
# can be done with ldapmodify.

["set_global_acl"].each do |basename|

  ldif_template = File.read("templates/#{basename}.ldif.erb")
  ldif = ERB.new(ldif_template, 0, "%<>")

  tempfile = Tempfile.open(basename)
  tempfile.puts ldif.result
  tempfile.close

  puts `cat #{tempfile.path}`
  puts `ldapmodify -Y EXTERNAL -H ldapi:/// -f #{tempfile.path} 2>&1`

  tempfile.delete
end
