#!/usr/bin/ruby1.9.1

# Add lib path for development
$LOAD_PATH.unshift(
  File.expand_path(
    File.join( File.dirname(__FILE__), '..', 'lib' )
  )
)

require 'erb'
require 'yaml'
require 'tempfile'
require 'optparse'
require 'fileutils'
require 'socket'

require 'puavo/etc'
require 'puavo-ds/templates'

# Assertive shell exec. Raises runtime error if given command does not exit
# with 0
def assert_exec(cmd)
  out = `#{ cmd }`
  if not $?.success?
    raise "Failed to execute '#{ cmd }'"
  end
  return out
end

def parse_erb(basename)
  ldif_template = File.read("#{ TEMPLATES_PATH }/#{basename}.ldif.erb")
  ldif = ERB.new(ldif_template, 0, "%<>")

  tempfile = Tempfile.open(basename)
  tempfile.puts ldif.result
  tempfile.close

  return tempfile
end

# Ask puavo_attr for /etc/puavo with given question
# @param {String} question Question printed to screen
# @param {Symbol} puavo_attr Puavo attribute to be written to /etc/puavo
# @param {String} [default] Default value for new Puavo attributes
# @return {String} new value
def ask_puavo_attr(question, puavo_attr, default=nil)

  begin
    default = PUAVO_ETC.send(puavo_attr)
  rescue Errno::ENOENT
  end

  while true
    print "#{question} [#{ default }]> "
    new_value = STDIN.gets.strip

    # Use default or previous value if user did not give anything
    new_value = default if new_value.to_s.empty?

    # Break only when we have a value
    break if not new_value.to_s.empty?
  end

  PUAVO_ETC.write(puavo_attr.to_sym, new_value)
  return new_value
end



puts "\nInitialize slapd with Puavo configuration"
puts

# Ask Puavo attributes for /puavo/etc and save them to instance variable for
# the erb templates
@rootdn = ask_puavo_attr("root dn", :ldap_dn, "uid=admin,o=puavo")
@rootpw = ask_puavo_attr("root password", "ldap_password")

@puavodn = ask_puavo_attr("puavo dn", :ds_puavo_dn, "uid=puavo,o=puavo")
@puavopw = ask_puavo_attr("puavo password", "ds_puavo_password")

@puppetdn = ask_puavo_attr("puppet dn", :ds_puppet_dn, "uid=puppet,o=puavo")
@puppetpw = ask_puavo_attr("puppet password", "ds_puppet_password")

@kdcdn = ask_puavo_attr("kdc dn", :ds_kdc_dn, "uid=kdc,o=puavo")
@kdcpw = ask_puavo_attr("kdc password", :ds_kdc_password)

@kadmindn = ask_puavo_attr("kadmin dn", :ds_kadmin_dn, "uid=kadmin,o=puavo")
@kadminpw = ask_puavo_attr("kadmin password", :ds_kadmin_password)

@monitordn = ask_puavo_attr("monitor dn", :ds_monitor_dn, "uid=monitor,o=puavo")
@monitorpw = ask_puavo_attr("monitor password", :ds_monitor_password)

@slavedn = ask_puavo_attr("slave dn", :ds_slave_dn, "uid=slave,o=puavo")
@slavepw = ask_puavo_attr("slave password", "ds_slave_password")

puts "Using #{@rootdn} as rootdn"

@rootpw_hash=`slappasswd -h "{SSHA}" -s "#{@rootpw}"`.gsub(/\n/,"")
@puavopw_hash=`slappasswd -h "{SSHA}" -s "#{@puavopw}"`.gsub(/\n/,"")
@puppetpw_hash=`slappasswd -h "{SSHA}" -s "#{@puppetpw}"`.gsub(/\n/,"")
@kdcpw_hash=`slappasswd -h "{SSHA}" -s "#{@kdcpw}"`.gsub(/\n/,"")
@kadminpw_hash=`slappasswd -h "{SSHA}" -s "#{@kadminpw}"`.gsub(/\n/,"")

print <<EOF
I'm now going to initialize new LDAP databases on this machine.
This will destroy previous databases permanently.
EOF

while true
  print "Type YES to continue> "
  break if STDIN.gets.strip == "YES"
end

# Make sure that slapd is not running
`/etc/init.d/slapd stop`
`killall -9 slapd`
FileUtils.rm_r Dir.glob('/var/lib/ldap/*')

# AppArmor rules allow slapd to access files under /var/lib/ldap so
# we'll just create new directories under it for different databases:
#
# /var/lib/ldap/o=puavo

FileUtils.mkdir_p '/var/lib/ldap/o=puavo'

FileUtils.rm_r Dir.glob('/etc/ldap/slapd.d/*')

# Check that the certificate files can be found
["/etc/ssl/certs/slapd-ca.crt",
 "/etc/ssl/certs/slapd-server.crt",
 "/etc/ssl/certs/slapd-server.key"].each do |file|
  if not File.exists?(file)
    raise "Certificate file not found! #{file}."
  end
end

# As /etc/ldap/slapd.d is now totally empty, slapd won't start before
# initial config is added with slapadd.
#
# Initialize cn=config from a template ldif file

tempfile = parse_erb("init_ldap")
puts assert_exec "slapadd -l #{tempfile.path} -F /etc/ldap/slapd.d -b \"cn=config\""
tempfile.delete

# Initialize o=puavo from a template ldif file

tempfile = parse_erb("init_puavo_db")
puts assert_exec "slapadd -l #{tempfile.path} -F /etc/ldap/slapd.d -b \"o=Puavo\""
tempfile.delete

# slapdadd leaves the files owner by root, so let's fix those

FileUtils.chown_R 'openldap', 'openldap', '/etc/ldap/slapd.d'
FileUtils.chown_R 'openldap', 'openldap', '/var/lib/ldap/o=puavo'
FileUtils.chmod 0750, '/var/lib/ldap/o=puavo'

assert_exec '/etc/init.d/slapd start'
sleep 5

# slapd should be running now and the rest of the modifications
# can be done with ldapmodify.

["set_global_acl"].each do |basename|

  ldif_template = File.read("#{ TEMPLATES_PATH }/#{basename}.ldif.erb")
  ldif = ERB.new(ldif_template, 0, "%<>")

  tempfile = Tempfile.open(basename)
  tempfile.puts ldif.result
  tempfile.close

  puts `cat #{tempfile.path}`
  puts `ldapmodify -Y EXTERNAL -H ldapi:/// -f #{tempfile.path} 2>&1`

  tempfile.delete
end

# LDAP master address is this machine + topdomain
PUAVO_ETC.write(:ldap_master, "#{ Socket.gethostname }.#{ PUAVO_ETC.topdomain }")

puts "Test: ldapsearch -ZZ -h #{ PUAVO_ETC.ldap_master } -D uid=admin,o=puavo -w #{ @rootpw } -x -b o=puavo"
puts "LDAP init ok!"
